<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-US"><generator uri="https://jekyllrb.com/" version="3.9.5">Jekyll</generator><link href="http://localhost:4000/feed/by_tag/Playwright.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="en-US" /><updated>2026-01-14T13:53:07+02:00</updated><id>http://localhost:4000/feed/by_tag/Playwright.xml</id><title type="html">Vadym Nastoiashchyi</title><subtitle>Software quality fanatic | Software Engineer in Test</subtitle><author><name>Vadym Nastoiashchyi</name></author><entry><title type="html">üé≠Playwright Parallelism: Why the Playwright sharding approach speeds up test execution over workers?</title><link href="http://localhost:4000/playwright-parallelism-why-the-playwright-sharding-approach-speeds-up-test-execution" rel="alternate" type="text/html" title="üé≠Playwright Parallelism: Why the Playwright sharding approach speeds up test execution over workers?" /><published>2026-01-10T21:00:00+02:00</published><updated>2026-01-10T21:00:00+02:00</updated><id>http://localhost:4000/playwright-parallelism-why-the-playwright-sharding-approach-speeds-up-test-execution</id><content type="html" xml:base="http://localhost:4000/playwright-parallelism-why-the-playwright-sharding-approach-speeds-up-test-execution"><![CDATA[<p><img src="http://localhost:4000/assets/images/posts/2026-01-10-playwright-parallelism-why-the-playwright-sharding-approach-speeds-up-test-execution/0_ibq0p6HzRRqGlPYv.png" alt="_config.yml" class="align-center border max-width-600px" /></p>

<p>In the previous article, I introduced you to <a href="https://medium.com/javascript-in-plain-english/playwright-compare-the-performance-of-different-test-parallelization-approaches-7698f1ee6523">üé≠ Playwright. Compare the performance of different test parallelization approaches.</a> Now, I shift the focus to test parallelization with the sharding approach, which plays a vital role in accelerating test execution using Playwright as a test framework.</p>

<p>The topic of parallel test execution has always interested other test automation engineers and me, regardless of the automated testing tools we use. In this article, I explain how Playwright works with parallelism and offer recommendations based on my research and analysis.</p>

<h2 id="to-properly-understand-parallelism-in-playwright-we-need-to-take-a-quick-look-at-low-level-computer-architecture">To properly understand parallelism in Playwright, we need to take a quick look at low-level computer architecture.</h2>

<p><em>I promise it won‚Äôt take long, but it might be a bit boring.</em></p>

<p>Our computer (my and yours) consists of various components, such as a hard drive, RAM, and a processor, etc. Here, we are most interested in the processor, specifically its ‚ÄúClock Speed‚Äù and the number of cores. Cores play an important role in the simultaneous execution of parallel processes. ‚ÄúClock Speed‚Äù determines how much work the processor can do in a given time. Here‚Äôs more information: <a href="https://www.intel.com/content/www/us/en/gaming/resources/cpu-clock-speed.html">What Is Clock Speed?</a></p>

<p>The following scheme provides us with greater visualization capabilities that we will apply to our Playwright parallelization mechanism:</p>

<p><img src="http://localhost:4000/assets/images/posts/2026-01-10-playwright-parallelism-why-the-playwright-sharding-approach-speeds-up-test-execution/1_nfZZJif8Lb1Hh49gxUGjBw.jpeg" alt="_config.yml" class="align-center border max-width-600px" /></p>

<p>When we use Playwright on one computer with the <code class="language-plaintext highlighter-rouge">--workers=</code> flag to run our tests in parallel, a Node.js process will be created for us. More information about processes can be found <a href="https://dev-aditya.medium.com/understanding-processes-and-threads-in-node-js-a-deep-dive-into-concurrency-and-parallelism-67e2cd2d5f0c">here</a>.</p>

<p>There is a clear dependency between workers and processor cores here. If there are fewer workers than cores, everything will work properly. As shown in the diagram, everything will execute in parallel at the same time.</p>

<p><img src="http://localhost:4000/assets/images/posts/2026-01-10-playwright-parallelism-why-the-playwright-sharding-approach-speeds-up-test-execution/1_TYCcNcPTTYPjUN9OeID1SQ.png" alt="_config.yml" class="align-center border max-width-600px" /></p>

<p>However, if we have 4 workers and 2 processor cores, certain workers will not run truly in parallel. Not everything will run at the same time, but processor time will be shared.</p>

<p><img src="http://localhost:4000/assets/images/posts/2026-01-10-playwright-parallelism-why-the-playwright-sharding-approach-speeds-up-test-execution/1_rCVNsTeTxe0qZZIcQ0il9Q.png" alt="_config.yml" class="align-center border max-width-600px" /></p>

<p>For example, on a CI/CD runner where we run our tests with more workers than available cores, we will not see an improvement in test execution time. This is because the workers share the processor time on the available cores. Even though we specify 10 or 20 workers.</p>

<p>You ask, ‚ÄúWhat should I do in this case?‚Äù It‚Äôs simple: Add additional runners using the sharding mechanism. For each runner, you can specify the number of workers based on the number of cores available on the processors. More information about sharding <a href="https://playwright.dev/docs/test-sharding">here</a></p>

<p><a href="https://github.com/VadimNastoyashchy/vadimnastoyashchy.github.io/blob/master/.github/workflows/pr_master.yml">Here is an example of how to describe the sharding mechanism in GitHub Actions:</a></p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="rouge-code"><pre><span class="na">e2e_tests</span><span class="pi">:</span>
  <span class="na">timeout-minutes</span><span class="pi">:</span> <span class="m">60</span>
  <span class="na">runs-on</span><span class="pi">:</span> <span class="s">ubuntu-latest</span>
  <span class="na">env</span><span class="pi">:</span>
    <span class="na">CI</span><span class="pi">:</span> <span class="no">true</span>
  <span class="na">strategy</span><span class="pi">:</span>
    <span class="na">fail-fast</span><span class="pi">:</span> <span class="no">false</span>
    <span class="na">matrix</span><span class="pi">:</span>
      <span class="na">shardIndex</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">1</span><span class="pi">,</span> <span class="nv">2</span><span class="pi">,</span> <span class="nv">3</span><span class="pi">,</span> <span class="nv">4</span><span class="pi">]</span>
      <span class="na">shardTotal</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">4</span><span class="pi">]</span>
  <span class="na">steps</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Checkout repository</span>
      <span class="na">uses</span><span class="pi">:</span> <span class="s">actions/checkout@v2</span>

    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Setup Node.js</span>
      <span class="na">uses</span><span class="pi">:</span> <span class="s">actions/setup-node@v2</span>
      <span class="na">with</span><span class="pi">:</span>
        <span class="na">node-version</span><span class="pi">:</span> <span class="s1">'</span><span class="s">22'</span>

    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Install E2E dependencies</span>
      <span class="na">run</span><span class="pi">:</span> <span class="s">npm ci</span>

    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Install Playwright browsers</span>
      <span class="na">run</span><span class="pi">:</span> <span class="s">npx playwright install --with-deps</span>

    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Run regression tests</span>
      <span class="na">run</span><span class="pi">:</span> <span class="s">npx playwright test --shard=$/$ --workers=2</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>In such an example, 4 runners (computers) and 2 workers for each. So we have 8 truly parallel processes.</p>

<h2 id="summary">Summary</h2>

<p>In summary, we can continuously improve the execution time of our tests by adding more runners (computers), provided that we follow best practices when developing and designing tests with an independent architecture.</p>

<p>I hope this article has shed some light on the obscure area of parallelization. Improve your test execution times, and remember about processor cores)</p>]]></content><author><name>Vadym Nastoiashchyi</name></author><category term="JavaScript" /><category term="Playwright" /><category term="Performance" /><category term="CI/CD" /><summary type="html"><![CDATA[In this article, I explain how Playwright works with parallelism and offer recommendations based on my research and analysis. The topic of parallel test execution has always interested other test automation engineers and me, regardless of the automated testing tools we use.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/images/posts/2026-01-10-playwright-parallelism-why-the-playwright-sharding-approach-speeds-up-test-execution/0_ibq0p6HzRRqGlPYv.png" /><media:content medium="image" url="http://localhost:4000/assets/images/posts/2026-01-10-playwright-parallelism-why-the-playwright-sharding-approach-speeds-up-test-execution/0_ibq0p6HzRRqGlPYv.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">üîùJavaScript UI Test Automation Frameworks‚Ää-‚Äälatest updates in¬†2025 part 3</title><link href="http://localhost:4000/javascript-ui-test-automation-frameworks-latest-updates-3" rel="alternate" type="text/html" title="üîùJavaScript UI Test Automation Frameworks‚Ää-‚Äälatest updates in¬†2025 part 3" /><published>2025-08-01T14:00:00+03:00</published><updated>2025-08-01T14:00:00+03:00</updated><id>http://localhost:4000/javascript-ui-test-automation-frameworks-latest-updates-3</id><content type="html" xml:base="http://localhost:4000/javascript-ui-test-automation-frameworks-latest-updates-3"><![CDATA[<p><img src="http://localhost:4000/assets/images/posts/2024-12-17-javascript-ui-test-automation-frameworks-which-one-is-faster/1_jlskksKL_ZgiQzxnoeoYPw.webp" alt="_config.yml" class="align-center border max-width-600px" /></p>

<p><em>Today I have prepared an equally interesting article. Playwright, WebdriverIO, and Cypress are currently the top testing frameworks. They‚Äôre always adding new features because of the competition. If you‚Äôre an automation or software development engineer, it‚Äôs crucial to stay on top of the latest functionalities. This article will give you the latest updates from 2025.</em></p>

<h2 id="cypress">Cypress</h2>

<h2 id="1440--1453">14.4.0 | 14.5.3</h2>

<p><strong>Breaking Changes:</strong></p>

<ul>
  <li>
    <p>@cypress/webpack-dev-server and @cypress/webpack-batteries-included-preprocessor now ship with webpack-bundle-analyzer as a diagnostic tool to determine bundle statistics, which can be enabled via DEBUG=cypress-verbose:webpack-dev-server:bundle-analyzer (component tests using webpack) or DEBUG=cypress-verbose:webpack-batteries-included-preprocessor:bundle-analyzer (e2e tests using webpack, which is the default preprocessor), respectively.</p>
  </li>
  <li>
    <p>Install Cypress win32-x64 binary on Windows win32-arm64 systems. Cypress runs in emulation.</p>
  </li>
</ul>

<p><strong>Bugfixes:</strong></p>

<ul>
  <li>
    <p>Fixed an issue where cy.session() may fail internally if navigating to about:blank takes longer than the defaultCommandTimeout.</p>
  </li>
  <li>
    <p>Fixed missing support for setting an absolute path for component.indexHtmlFile in @cypress/webpack-dev-server.</p>
  </li>
  <li>
    <p>Fixed an issue where TypeScript ESM projects using .js and .mjs extensions were not resolving correctly within @cypress/webpack-batteries-included-preprocessor.</p>
  </li>
  <li>
    <p>Fixed an issue in @cypress/angular where component instance fields were not reference safe and were being overwritten.</p>
  </li>
</ul>

<h2 id="playwright">Playwright</h2>

<h2 id="version-153--154">Version 1.53 | 1.54</h2>

<ul>
  <li>Trace Viewer and HTML Reporter Updates
    <ul>
      <li>New Steps in Trace Viewer and HTML reporter:</li>
    </ul>
  </li>
</ul>

<p><img src="http://localhost:4000/assets/images/posts/2025-08-01-javascript-ui-test-automation-frameworks-latest-updates-3/image.png" alt="_config.yml" class="align-center border max-width-600px" /></p>

<ul>
  <li>New option in ‚Äòhtml‚Äô reporter to set the title of a specific test run:</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="k">import</span> <span class="p">{</span> <span class="nx">defineConfig</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">@playwright/test</span><span class="dl">'</span><span class="p">;</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">defineConfig</span><span class="p">({</span>
  <span class="na">reporter</span><span class="p">:</span> <span class="p">[[</span><span class="dl">'</span><span class="s1">html</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span> <span class="na">title</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Custom test run #1028</span><span class="dl">'</span> <span class="p">}]]</span>
<span class="p">});</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li>
    <p>New option kind in <code class="language-plaintext highlighter-rouge">testInfo.snapshotPath()</code> controls which snapshot path template is used.</p>
  </li>
  <li>
    <p>New method <code class="language-plaintext highlighter-rouge">locator.describe()</code> to describe a locator. Used for trace viewer and reports.</p>
  </li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="kd">const</span> <span class="nx">button</span> <span class="o">=</span> <span class="nx">page</span><span class="p">.</span><span class="nx">getByTestId</span><span class="p">(</span><span class="dl">'</span><span class="s1">btn-sub</span><span class="dl">'</span><span class="p">).</span><span class="nx">describe</span><span class="p">(</span><span class="dl">'</span><span class="s1">Subscribe button</span><span class="dl">'</span><span class="p">);</span>
<span class="k">await</span> <span class="nx">button</span><span class="p">.</span><span class="nx">click</span><span class="p">();</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">npx playwright install --list</code> will now list all installed browsers, versions and locations.</p>
  </li>
  <li>
    <p>New cookie property <code class="language-plaintext highlighter-rouge">partitionKey</code> in <code class="language-plaintext highlighter-rouge">browserContext.cookies()</code> and <code class="language-plaintext highlighter-rouge">browserContext.addCookies()</code>. This property allows to save and restore partitioned cookies. See CHIPS MDN article for more information. Note that browsers have different support and defaults for cookie partitioning.</p>
  </li>
  <li>
    <p>New option noSnippets to disable code snippets in the html report.</p>
  </li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="k">import</span> <span class="p">{</span> <span class="nx">defineConfig</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">@playwright/test</span><span class="dl">'</span><span class="p">;</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">defineConfig</span><span class="p">({</span>
  <span class="na">reporter</span><span class="p">:</span> <span class="p">[[</span><span class="dl">'</span><span class="s1">html</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span> <span class="na">noSnippets</span><span class="p">:</span> <span class="kc">true</span> <span class="p">}]]</span>
<span class="p">});</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li>New property <code class="language-plaintext highlighter-rouge">location</code> in test annotations, for example in t<code class="language-plaintext highlighter-rouge">estResult.annotations</code> and <code class="language-plaintext highlighter-rouge">testInfo.annotations</code>. It shows where the annotation like <code class="language-plaintext highlighter-rouge">test.skip</code> or <code class="language-plaintext highlighter-rouge">test.fixme</code> was added.</li>
</ul>

<h2 id="webdriver-io">Webdriver IO</h2>

<h2 id="v9140--v9184">v9.14.0 | v9.18.4</h2>

<ul>
  <li>
    <p>wdio-protocols, webdriver, webdriverio (WebDriver Bidi Protocol update)</p>
  </li>
  <li>
    <p>wdio-config, wdio-runner, wdio-types (automatically include SoftAssertionService)</p>
  </li>
  <li>
    <p>lots of bug fixes</p>
  </li>
</ul>

<p>These are the latest updates we received in 2025. We continue to follow the development and updates of the most popular tools in the world of JavaScript testing</p>

<p><strong><em>Thanks to everyone who read this article, I hope you found it useful.</em></strong></p>

<p><em>Don‚Äôt hold yourself back from rating or commenting. You can also subscribe to the e-mail newsletter so that you don‚Äôt miss interesting things from the world of testing and development.</em></p>]]></content><author><name>Vadym Nastoiashchyi</name></author><category term="JavaScript" /><category term="Playwright" /><category term="Cypress" /><category term="WebdriverIO" /><summary type="html"><![CDATA[Playwright, WebdriverIO, and Cypress are currently the top testing frameworks. They're always adding new features because of the competition. If you're an automation or software development engineer, it's crucial to stay on top of the latest functionalities. This article will give you the latest updates from 2025....]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/images/posts/2024-12-17-javascript-ui-test-automation-frameworks-which-one-is-faster/1_jlskksKL_ZgiQzxnoeoYPw.webp" /><media:content medium="image" url="http://localhost:4000/assets/images/posts/2024-12-17-javascript-ui-test-automation-frameworks-which-one-is-faster/1_jlskksKL_ZgiQzxnoeoYPw.webp" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">üîùJavaScript UI Test Automation Frameworks‚Ää-‚Äälatest updates in¬†2025 part 2</title><link href="http://localhost:4000/javascript-ui-test-automation-frameworks-latest-updates-2" rel="alternate" type="text/html" title="üîùJavaScript UI Test Automation Frameworks‚Ää-‚Äälatest updates in¬†2025 part 2" /><published>2025-05-13T22:00:00+03:00</published><updated>2025-05-13T22:00:00+03:00</updated><id>http://localhost:4000/javascript-ui-test-automation-frameworks-latest-updates-2</id><content type="html" xml:base="http://localhost:4000/javascript-ui-test-automation-frameworks-latest-updates-2"><![CDATA[<p><img src="http://localhost:4000/assets/images/posts/2024-12-17-javascript-ui-test-automation-frameworks-which-one-is-faster/1_jlskksKL_ZgiQzxnoeoYPw.webp" alt="_config.yml" class="align-center border max-width-600px" /></p>

<p><em>Today I have prepared an equally interesting article. Playwright, WebdriverIO, and Cypress are currently the top testing frameworks. They‚Äôre always adding new features because of the competition. If you‚Äôre an automation or software development engineer, it‚Äôs crucial to stay on top of the latest functionalities. This article will give you the latest updates from early 2025.</em></p>

<h2 id="cypress">Cypress</h2>

<h2 id="1401--1433">14.0.1 | 14.3.3</h2>

<p><strong>Breaking Changes:</strong></p>

<ul>
  <li>Firefox versions 135 and above are now automated with WebDriver BiDi instead of Chrome Devtools Protocol.</li>
  <li>Cypress.stop() is now available to stop the Cypress App on the current machine while tests are running. This can be useful for stopping test execution upon failures or other predefined conditions.</li>
  <li>The UI above the application under test now displays in dark mode.</li>
  <li>The cy.press() command is now available. It supports dispatching native Tab keyboard events to the browser.</li>
  <li>Lots of bugfixes and performance optimizations</li>
</ul>

<h2 id="playwright">Playwright</h2>

<h2 id="version-151--152">Version 1.51 | 1.52</h2>

<ul>
  <li>New option indexedDB for browserContext.storageState() allows to save and restore IndexedDB contents. Useful when your application uses IndexedDB API to store authentication tokens, like Firebase Authentication.</li>
</ul>

<p>Here is an example following the authentication guide:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre>import { test as setup, expect } from '@playwright/test';
import path from 'path';

const authFile = path.join(__dirname, '../playwright/.auth/user.json');

setup('authenticate', async ({ page }) =&gt; {
  await page.goto('/');
  // ... perform authentication steps ...

  // make sure to save indexedDB
  await page.context().storageState({ path: authFile, indexedDB: true });
});
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li>New ‚ÄúCopy prompt‚Äù button on errors in the HTML report, trace viewer and UI mode. Click to copy a pre-filled LLM prompt that contains the error message and useful context for fixing the error.</li>
  <li>New option visible for locator.filter() allows matching only visible elements.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre>test('some test', async ({ page }) =&gt; {
  // Ignore invisible todo items.
  const todoItems = page.getByTestId('todo-item').filter({ visible: true });
  // Check there are exactly 3 visible ones.
  await expect(todoItems).toHaveCount(3);
});
</pre></td></tr></tbody></table></code></pre></div></div>
<ul>
  <li>Set option testConfig.captureGitInfo to capture git information into testConfig.metadata.
```
import { defineConfig } from ‚Äò@playwright/test‚Äô;</li>
</ul>

<p>export default defineConfig({
  captureGitInfo: { commit: true, diff: true }
});</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>- New method expect(locator).toContainClass() to ergonomically assert individual class names on the element.
</pre></td></tr></tbody></table></code></pre></div></div>
<p>await expect(page.getByRole(‚Äòlistitem‚Äô, { name: ‚ÄòShip v1.52‚Äô })).toContainClass(‚Äòdone‚Äô);</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>- Aria Snapshots got two new properties: /children for strict matching and /url for links.
</pre></td></tr></tbody></table></code></pre></div></div>
<p>await expect(locator).toMatchAriaSnapshot(`</p>
<ul>
  <li>list
    <ul>
      <li>/children: equal</li>
      <li>listitem: Feature A</li>
      <li>listitem:
        <ul>
          <li>link ‚ÄúFeature B‚Äù:
            <ul>
              <li>/url: ‚Äúhttps://playwright.dev‚Äù
<code class="language-plaintext highlighter-rouge">);
</code>``</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>New property testProject.workers allows to specify the number of concurrent worker processes to use for a test project. The global limit of property testConfig.workers still applies.</li>
  <li>New testConfig.failOnFlakyTests option to fail the test run if any flaky tests are detected, similarly to ‚Äìfail-on-flaky-tests. This is useful for CI/CD environments where you want to ensure that all tests are stable before deploying.</li>
  <li>New property testResult.annotations contains annotations for each test retry.</li>
</ul>

<h2 id="webdriver-io">Webdriver IO</h2>

<h2 id="v961--v9130">v9.6.1 | v9.13.0</h2>

<ul>
  <li>Use checkVisibility for display checks</li>
  <li>Accessibility Support for Browserstack app automate sessions</li>
  <li>Add deepLink command</li>
  <li>Add restartApp</li>
  <li>Distinguish Cucumber PENDING status in reporters</li>
  <li>Allow more options for screenshot taking with Bidi</li>
  <li>Support WebSocket options at the BiDi connection</li>
  <li>Add ‚Äúoptions‚Äù parameter to ‚ÄúterminateApp‚Äù command</li>
  <li>Introduce defineConfig function to create a typed configuration object</li>
  <li>Change gridProxyDetails request from GET to POST method</li>
  <li>Lots of bugfixes and performance optimizations</li>
</ul>

<p>These are the latest updates we received in 2025. We continue to follow the development and updates of the most popular tools in the world of JavaScript testing</p>

<p><strong><em>Thanks to everyone who read this article, I hope you found it useful.</em></strong></p>

<p><em>Don‚Äôt hold yourself back from rating or commenting. You can also subscribe to the e-mail newsletter so that you don‚Äôt miss interesting things from the world of testing and development.</em></p>]]></content><author><name>Vadym Nastoiashchyi</name></author><category term="JavaScript" /><category term="Playwright" /><category term="Cypress" /><category term="WebdriverIO" /><summary type="html"><![CDATA[Playwright, WebdriverIO, and Cypress are currently the top testing frameworks. They're always adding new features because of the competition. If you're an automation or software development engineer, it's crucial to stay on top of the latest functionalities. This article will give you the latest updates from 2025....]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/images/posts/2024-12-17-javascript-ui-test-automation-frameworks-which-one-is-faster/1_jlskksKL_ZgiQzxnoeoYPw.webp" /><media:content medium="image" url="http://localhost:4000/assets/images/posts/2024-12-17-javascript-ui-test-automation-frameworks-which-one-is-faster/1_jlskksKL_ZgiQzxnoeoYPw.webp" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">üé≠Playwright. Useful video‚Äôs in 2025</title><link href="http://localhost:4000/playwright-useful-videos-youtube" rel="alternate" type="text/html" title="üé≠Playwright. Useful video‚Äôs in 2025" /><published>2025-02-16T21:00:00+02:00</published><updated>2025-02-16T21:00:00+02:00</updated><id>http://localhost:4000/playwright-useful-videos-youtube</id><content type="html" xml:base="http://localhost:4000/playwright-useful-videos-youtube"><![CDATA[<p>I‚Äôve been asked for a long time what video courses or lessons I can recommend to colleagues who want to learn or improve their knowledge of Playwright. So in this article I‚Äôve collected some interesting channels that might be useful.</p>

<h2 id="joanmedia"><a href="https://www.youtube.com/@joanmedia">JoanMedia</a></h2>

<div class="embed-container">
  <iframe src="https://www.youtube.com/embed/6fapvF1uYo0?si=E15eDQRyYw8bwdSE" width="700" height="480" frameborder="0" allowfullscreen="true">
  </iframe>
</div>

<p><br /></p>

<h2 id="testers-talk"><a href="https://www.youtube.com/@testerstalk">Testers Talk</a></h2>

<div class="embed-container">
  <iframe src="https://www.youtube.com/embed/2poXBtifpzA?si=FRJtfI3rSNf9PAb6" width="700" height="480" frameborder="0" allowfullscreen="true">
  </iframe>
</div>

<p><br /></p>

<h3 id="mukesh-otwani"><a href="https://www.youtube.com/@Mukeshotwani">Mukesh otwani</a></h3>

<div class="embed-container">
  <iframe src="https://www.youtube.com/embed/pq20Gd4LXeI?si=6nTqieQoX1uaTUb8" width="700" height="480" frameborder="0" allowfullscreen="true">
  </iframe>
</div>

<p><br /></p>

<p>Currently, these are the top 3 channels for learning Playwright that can be useful for both beginners and experienced engineers. I hope you find these videos useful and informative.</p>

<p><strong><em>Thanks to everyone who read this article, I hope you found it useful.</em></strong></p>

<p><em>Don‚Äôt hold yourself back from rating or commenting. You can also subscribe to the e-mail newsletter so that you don‚Äôt miss interesting things from the world of testing and development.</em></p>]]></content><author><name>Vadym Nastoiashchyi</name></author><category term="JavaScript" /><category term="Playwright" /><summary type="html"><![CDATA[I've been asked for a long time what video courses or lessons I can recommend to colleagues who want to learn or improve their knowledge of Playwright. So in this article I've collected some interesting channels that might be useful...]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/images/posts/2024-12-05-playwright-compare-the-performance-of-different-test-parallelization-approaches/0_OWmrZjf95TDjGa2B.webp" /><media:content medium="image" url="http://localhost:4000/assets/images/posts/2024-12-05-playwright-compare-the-performance-of-different-test-parallelization-approaches/0_OWmrZjf95TDjGa2B.webp" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">üîùJavaScript UI Test Automation Frameworks‚Ää-‚Äälatest updates in¬†2025</title><link href="http://localhost:4000/javascript-ui-test-automation-frameworks-latest-updates" rel="alternate" type="text/html" title="üîùJavaScript UI Test Automation Frameworks‚Ää-‚Äälatest updates in¬†2025" /><published>2025-02-03T21:00:00+02:00</published><updated>2025-02-03T21:00:00+02:00</updated><id>http://localhost:4000/javascript-ui-test-automation-frameworks-latest-updates</id><content type="html" xml:base="http://localhost:4000/javascript-ui-test-automation-frameworks-latest-updates"><![CDATA[<p><em>Today I have prepared an equally interesting article. Playwright, WebdriverIO, and Cypress are currently the top testing frameworks. They‚Äôre always adding new features because of the competition. If you‚Äôre an automation or software development engineer, it‚Äôs crucial to stay on top of the latest functionalities. This article will give you the latest updates from early 2025.</em></p>

<figure id="image" class="image">
  <img src="http://localhost:4000/assets/images/posts/2024-12-17-javascript-ui-test-automation-frameworks-which-one-is-faster/1_jlskksKL_ZgiQzxnoeoYPw.webp" alt="" />
  <figcaption id="img-caption"></figcaption>
</figure>

<h2 id="cypress">Cypress</h2>

<h2 id="1400--1401">14.0.0 | 14.0.1</h2>

<p>Cypress v14.0.0 is pretty solid. It‚Äôll give your component testing a nice boost and you‚Äôll be all set for the new framework and dev server versions. It‚Äôs also got some breaking changes to cy.origin, which are needed to deal with Chrome‚Äôs deprecation of document.domain injection. This should fix some issues for some users in the latest Chrome versions. But keep in mind that support for older versions of Node.js, Linux distributions, browsers, and component testing frameworks and dev servers is being phased out.</p>

<p><strong>Breaking Changes:</strong></p>

<p>Refer to the <a href="https://docs.cypress.io/app/references/migration-guide#Migrating-to-Cypress-140">v14 Migration Guide</a> for help migrating your code.</p>

<ul>
  <li>
    <p>Removed support for Node.js 16 and Node.js 21. Addresses <a href="https://github.com/cypress-io/cypress/issues/29930">#29930</a>.</p>
  </li>
  <li>
    <p>Cypress now only officially supports the latest 3 major versions of Chrome, Firefox, and Edge ‚Äî older browser versions may still work, but we recommend keeping your browsers up to date to ensure compatibility with Cypress. A warning will no longer be displayed on browser selection in the Launchpad for any ‚Äòunsupported‚Äô browser versions. Additionally, the undocumented minSupportedVersion property has been removed from Cypress.browser. Addressed in <a href="https://github.com/cypress-io/cypress/pull/30462">#30462</a>.</p>
  </li>
  <li>
    <p>The cy.origin() command must now be used when navigating between subdomains. Because this is a fairly disruptive change for users who frequently navigate between subdomains, a new configuration option is being introduced. injectDocumentDomain can be set to true in order to re-enable the injection of document.domain setters in Cypress. This configuration option is marked as deprecated and you‚Äôll receive a warning when Cypress is launched with this option set to true. It will be removed in Cypress 15. Addressed in <a href="https://github.com/cypress-io/cypress/pull/30770">#30770</a>.</p>
  </li>
</ul>

<h2 id="playwright">Playwright</h2>

<h2 id="version-150--149">Version 1.50 | 1.49</h2>

<ul>
  <li>New option <a href="https://playwright.dev/docs/api/class-test#test-step-option-timeout">timeout</a> allows specifying a maximum run time for an individual test step. A timed-out step will fail the execution of the test.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre>    test('some test', async ({ page }) =&gt; {
      await test.step('a step', async () =&gt; {
        // This step can time out separately from the test
      }, { timeout: 1000 });
    });
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li>New method <a href="https://playwright.dev/docs/api/class-test#test-step-skip">test.step.skip()</a> to disable the execution of a test step.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre>    test('some test', async ({ page }) =&gt; {
      await test.step('before running step', async () =&gt; {
        // Normal step
      });

      await test.step.skip('not yet ready', async () =&gt; {
        // This step is skipped
      });

      await test.step('after running step', async () =&gt; {
        // This step still runs even though the previous one was skipped
      });
    });‚Äã
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li>New assertion <a href="https://playwright.dev/docs/api/class-locatorassertions#locator-assertions-to-match-aria-snapshot">expect(locator).toMatchAriaSnapshot()</a> verifies page structure by comparing to an expected accessibility tree, represented as YAML.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre>    await page.goto('https://playwright.dev');
    await expect(page.locator('body')).toMatchAriaSnapshot(`
      - banner:
        - heading /Playwright enables reliable/ [level=1]
        - link "Get started"
        - link "Star microsoft/playwright on GitHub"
      - main:
        - img "Browsers (Chromium, Firefox, WebKit)"
        - heading "Any browser ‚Ä¢ Any platform ‚Ä¢ One API"
    `);
</pre></td></tr></tbody></table></code></pre></div></div>

<p>You can generate this assertion with <a href="https://playwright.dev/docs/codegen">Test Generator</a> and update the expected snapshot with ‚Äìupdate-snapshots command line flag.</p>

<p>Learn more in the <a href="https://playwright.dev/docs/aria-snapshots">aria snapshots guide</a>.</p>

<h2 id="webdriver-io">Webdriver IO</h2>

<h2 id="v960--v950">v9.6.0 | v9.5.0</h2>

<ul>
  <li>
    <p>The team has added AppAccessibility Scans support for the BrowserStack app automated sessions. Before, accessibility support was only available for Web Automation. Now, it is also available for App Automation.</p>
  </li>
  <li>
    <p>The web platform now has a checkVisibility function that lets you see if an element is visible or not. It‚Äôs better to use this new version than to maintain our version, which we got from a different project. This also changes how the function is run, showing the function name if it is available. This makes it easier to understand which WebdriverIO helper functions were used in the logs. This ‚Äúshould‚Äù be a non-breaking change, but it‚Äôs hard to say for sure since it‚Äôs not clear how the custom script worked.</p>
  </li>
  <li>
    <p>Added a Mobile Native swipe command and contains the following:</p>
  </li>
  <li>new swipe for native apps method</li>
  <li>scrollIntoView to make it dependent on the swipe</li>
  <li>UTs for scrollIntoView</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre>    it('should execute a default swipe', async () =&gt; {
        await browser.swipe();
    });

    it('should execute a swipe with options', async () =&gt; {
        await browser.swipe({
            direction: 'left',                  // Swipe from right to left
            duration: 5000,                     // Last for 5 seconds
            percent: 0.5,                       // Swipe 50% of the scrollableElement
            scrollableElement: $('~carousel'),  // The element to swipe within
        })
    });
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li>
    <p>Added the mobile tap command including</p>
  </li>
  <li>native tap on coordinates</li>
  <li>web tap on coordinates</li>
  <li>native tap on element + automatically scrolling when the element is not visible on the native tap</li>
  <li>web tab on element</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="rouge-code"><pre>    it('should be able to tap an on element', async () =&gt; {
        const elem = $('~myElement')
        // It will automatically scroll to the element if it's not already in the viewport
        await elem.tap()
    })

    it('should be able to swipe right 3 times in a custom scroll areas to an element and tap on the element', async () =&gt; {
        const elem = $('~myElement')
        // Swipe right 3 times in the custom scrollable element to find the element
        await elem.tap({
            direction: 'right',
            maxScrolls: 3,
            scrollableElement: $('#scrollable')
        })
    })

    it('should be able to tap on screen coordinates', async () =&gt; {
        await browser.tap({ x: 200, y: 400 })
    })
</pre></td></tr></tbody></table></code></pre></div></div>

<p>These are the updates we received in early 2025. We continue to follow the development and updates of the most popular tools in the world of JavaScript testing</p>

<p><strong><em>Thanks to everyone who read this article, I hope you found it useful.</em></strong></p>

<p><em>Don‚Äôt hold yourself back from rating or commenting. You can also subscribe to the e-mail newsletter so that you don‚Äôt miss interesting things from the world of testing and development.</em></p>]]></content><author><name>Vadym Nastoiashchyi</name></author><category term="JavaScript" /><category term="Playwright" /><category term="Cypress" /><category term="WebdriverIO" /><summary type="html"><![CDATA[Playwright, WebdriverIO, and Cypress are currently the top testing frameworks. They're always adding new features because of the competition. If you're an automation or software development engineer, it's crucial to stay on top of the latest functionalities. This article will give you the latest updates from early 2025....]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/images/posts/2024-12-17-javascript-ui-test-automation-frameworks-which-one-is-faster/1_jlskksKL_ZgiQzxnoeoYPw.webp" /><media:content medium="image" url="http://localhost:4000/assets/images/posts/2024-12-17-javascript-ui-test-automation-frameworks-which-one-is-faster/1_jlskksKL_ZgiQzxnoeoYPw.webp" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">üîùJavaScript UI Test Automation Frameworks ‚Äî which one is faster?</title><link href="http://localhost:4000/javascript-ui-test-automation-frameworks-which-one-is-faster" rel="alternate" type="text/html" title="üîùJavaScript UI Test Automation Frameworks ‚Äî which one is faster?" /><published>2024-12-17T21:00:00+02:00</published><updated>2024-12-17T21:00:00+02:00</updated><id>http://localhost:4000/javascript-ui-test-automation-frameworks-which-one-is-faster</id><content type="html" xml:base="http://localhost:4000/javascript-ui-test-automation-frameworks-which-one-is-faster"><![CDATA[<p><img src="http://localhost:4000/assets/images/posts/2024-12-17-javascript-ui-test-automation-frameworks-which-one-is-faster/1_jlskksKL_ZgiQzxnoeoYPw.webp" alt="_config.yml" class="align-center border max-width-600px" /></p>

<p><em>I continue to share interesting experiences and tips from the automation testing world. So far we‚Äôve discussed the following:</em></p>

<p><img src="https://medium.com/javascript-in-plain-english/playwright-compare-the-performance-of-different-test-parallelization-approaches-7698f1ee6523" alt="[*üé≠Playwright. Compare the performance of different test parallelization approaches.](https://medium.com/javascript-in-plain-english/playwright-compare-the-performance-of-different-test-parallelization-approaches-7698f1ee6523)*](https://cdn-images-1.medium.com/max/2540/1*VdHXUgs7bNmA8kA8VO8Evg.png)[*üé≠Playwright. Compare the performance of different test parallelization approaches." /></p>

<p><em>Today I have prepared an equally interesting article. As you can see from the title, we are going to compare the performance of three of the most popular system (UI) testing tools. 
<a href="https://playwright.dev/">Playwright</a>, <a href="https://webdriver.io/">WebdriverIO</a>, and <a href="https://www.cypress.io/">Cypress</a> will be our guinea pigs today.</em></p>

<p>When choosing the right automation tool for testing, we are usually guided by the programming language our team works in, the need to support certain browsers, whether we need to support mobile testing, how we can parallelize tests, how the tool will be supported and extended, and so on. And that is true. In addition to the above, knowing the test execution performance (speed) of a particular tool will be a plus when deciding what to use for automated testing.</p>

<h3 id="why-playwright">Why Playwright?</h3>
<blockquote>
  <p>‚Äî Multi-browser Support: Playwright supports all the major browsers (Chromium, Firefox, and WebKit) out of the box, which means you can test across all browsers with the same API.
 ‚Äî Cross-platform: It works on Windows, Linux, and macOS.
 ‚Äî Auto-waits: The API automatically waits for elements to be ready before performing actions, reducing flakiness in tests.
 ‚Äî Rich set of APIs: Offers APIs to simulate various inputs including keyboard, mouse, and touch, as well as network and context manipulation.
 ‚Äî Language Support: First-class support for JavaScript/TypeScript, and community-driven support for Python, Java, and C#.</p>
</blockquote>

<h3 id="why-webdriverio">Why WebDriverIO?</h3>
<blockquote>
  <p>‚Äî Flexible: It runs on top of Selenium, which means it has wide support for almost all browsers, even mobile browsers via Appium.
 ‚Äî Feature-rich: Contains a lot of plugins and services that can be integrated, like visual regression testing tools, and reporter tools, and even extends its functionalities using custom commands.
 ‚Äî Support for Multiple Test Frameworks: It supports Mocha, Jasmine, and Cucumber, meaning that you can use it with a variety of testing styles.
 ‚Äî Good community and ecosystem: Due to its integration with Selenium, it has a very strong community and a lot of third-party tools.</p>
</blockquote>

<h3 id="why-cypress">Why Cypress?</h3>
<blockquote>
  <p>‚Äî Developer-friendly: Provides a unique interactive test runner that allows you to see commands as they execute while also viewing the application UI.
 ‚Äî Automatic Waiting: Automatically waits for commands and assertions before moving on. No need to define explicit waits.
 ‚Äî Real-Time Reloads: Automatically reloads whenever you make changes to tests.
 ‚Äî Built-in Debuggability: You can use familiar dev tools for debugging directly during test execution.
 ‚Äî Network Traffic Control: Easily control, stub, and test edge cases without involving your server. You can intercept and modify network traffic on the fly.</p>
</blockquote>

<p>Together with <a href="https://www.linkedin.com/in/maryna-mala-5592a5177/">Maryna</a>, we prepared three repositories for these three tools, with four tests that were the same according to the scenario. For each of these tools, we checked the sequential execution of the tests in one thread locally and on GitHub action (one single machine). We ran the tests 3 times for data accuracy and took the total execution time from the average value.
Links to the repositories: <a href="https://github.com/Maryna-Mala/test-performance-playwright">Playwright</a> / <a href="https://github.com/Maryna-Mala/test-performance-wdio">WebdriverIO</a> / <a href="https://github.com/Maryna-Mala/test-performance-cypress">Cypress</a></p>

<h3 id="1-locally-run">#1 Locally run</h3>

<p><em>configuration:</em></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>MacBook Air m1 |  RAM 8 gb | SSD 256 | browser - chrome
</pre></td></tr></tbody></table></code></pre></div></div>

<p><img src="https://cdn-images-1.medium.com/max/3520/1*DmyIWnxZpfrbyiw_GOpObg.png" alt="" /></p>

<h3 id="results">Results:</h3>

<p><img src="https://cdn-images-1.medium.com/max/2000/1*IgYwEoEnn_qtuFZ4xXydlQ.png" alt="" /></p>

<p>We ran each tool three times, and as you can see from the results, Playwright took <em>13.4</em> seconds to complete, while WebdriverIO and Cypress took almost as long ‚Äî <em>18.3</em> and <em>18.7</em> seconds, respectively.</p>

<p><img src="https://cdn-images-1.medium.com/max/2000/1*JThx0MXsiBZeHcZ7Wrwmsw.png" alt="" /></p>

<h3 id="2-ci-run-githubaction">#2 CI run GithubAction</h3>

<p><em>configuration:</em></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre>Standard GitHub-hosted runners

Virtual Machine | (CPU) | (RAM) | (SSD) | Workflow
Linux           | 4     | 16 GB | 14 GB | ubuntu-latest
</pre></td></tr></tbody></table></code></pre></div></div>

<p>The situation with CI is a bit different. We measured the execution time of the tool itself as well as the execution time of the command. Some tools require additional time for verification or configuration before the runner is launched.</p>

<p><img src="https://cdn-images-1.medium.com/max/3008/1*YsuuBbYZDx76MI15vQawJQ.png" alt="" /></p>

<p><img src="https://cdn-images-1.medium.com/max/2000/1*RsWm2a-KLd3H_bXkukicEg.png" alt="" /></p>

<p>The Playwright was also the fastest tool in the CI run.</p>

<p><img src="https://cdn-images-1.medium.com/max/4180/1*y-0sWT7jGXNZPRZg6W0nMw.png" alt="playwright 15.8 sec / 17 sec" /><em>playwright 15.8 sec / 17 sec</em></p>

<p><img src="https://cdn-images-1.medium.com/max/4168/1*L3YIrbMUfZfm1eRtgfV_Tw.png" alt="webdriverio 30 sec / 32sec" /><em>webdriverio 30 sec / 32sec</em></p>

<p><img src="https://cdn-images-1.medium.com/max/4188/1*c4CgKVRJpA1Coq8FOu3kaw.png" alt="cypress 22 sec / 41sec" /><em>cypress 22 sec / 41sec</em></p>

<h3 id="conclusion">Conclusion</h3>

<p>The comparison of the three JavaScript UI test automation frameworks ‚Äî Playwright, WebdriverIO, and Cypress ‚Äî revealed notable differences in their performance both locally and on CI using GitHub Actions. Playwright emerged as the fastest tool in both environments, significantly outperforming the other two frameworks. Its comprehensive browser support, cross-platform capabilities, and robust APIs make it an advantageous choice for developers seeking efficiency and reliability in UI testing. WebdriverIO and Cypress also demonstrated commendable features, each suited to different testing needs and environments. This comparison provides valuable insight for teams considering automated testing tools, allowing them to make informed decisions based on speed, functionality, and compatibility with their testing needs.</p>

<p><strong><em>Thanks to everyone who read this article, I hope you found it useful.</em></strong></p>

<p>I would also like to thank <a href="https://www.linkedin.com/in/maryna-mala-5592a5177">Maryna</a> for her help in conducting and collecting data for this article.</p>]]></content><author><name>Vadym Nastoiashchyi</name></author><category term="JavaScript" /><category term="Playwright" /><category term="Cypress" /><category term="WebdriverIO" /><category term="Performance" /><summary type="html"><![CDATA[Today I have prepared an equally interesting article. As you can see from the title, we are going to compare the performance of three of the most popular system (UI) testing tools. Playwright, WebdriverIO, and Cypress will be our guinea pigs today...]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/images/posts/2024-12-17-javascript-ui-test-automation-frameworks-which-one-is-faster/1_jlskksKL_ZgiQzxnoeoYPw.webp" /><media:content medium="image" url="http://localhost:4000/assets/images/posts/2024-12-17-javascript-ui-test-automation-frameworks-which-one-is-faster/1_jlskksKL_ZgiQzxnoeoYPw.webp" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">üé≠Playwright. Compare the performance of different test parallelization approaches.</title><link href="http://localhost:4000/playwright-compare-the-performance-of-different-test-parallelization-approaches" rel="alternate" type="text/html" title="üé≠Playwright. Compare the performance of different test parallelization approaches." /><published>2024-12-05T21:00:00+02:00</published><updated>2024-12-05T21:00:00+02:00</updated><id>http://localhost:4000/playwright-compare-the-performance-of-different-test-parallelization-approaches</id><content type="html" xml:base="http://localhost:4000/playwright-compare-the-performance-of-different-test-parallelization-approaches"><![CDATA[<p><img src="http://localhost:4000/assets/images/posts/2024-12-05-playwright-compare-the-performance-of-different-test-parallelization-approaches/0_OWmrZjf95TDjGa2B.webp" alt="_config.yml" class="align-center border max-width-600px" /></p>

<p><em>I continue to share tips for playwrights and in the previous article, I showed you <a href="https://medium.com/softwaretestingdaily/playwright-how-to-build-page-object-correctly-using-fixtures-ff0a8c05b395">how to build a Page Object correctly using fixtures</a>. Now, I shift the focus to test parallelization, which plays a vital role in accelerating test execution using Playwright as a test framework.</em></p>

<p>Time is of the essence in software testing, where achieving quicker test results without compromising reliability is a primary objective for development teams. Playwright, an open-source browser automation library, is instrumental in testing modern web applications across different browsers. Parallelization further enhances the efficacy and efficiency of automated testing by reducing execution times.</p>

<p>In this article, we won‚Äôt delve into setting up parallelization but rather explore the variations in test execution times when deploying different parallelizing approaches.</p>

<p>According to the <a href="https://playwright.dev/docs/test-parallel">official documentation</a>:</p>

<h2 id="parallelism">Parallelism<a href="https://playwright.dev/docs/test-parallel#introduction">‚Äã</a></h2>

<p>Playwright Test runs tests in parallel. To achieve that, several worker processes are run at the same time. By default, test files are run in parallel. Tests in a single file are run in order, in the same worker process.</p>

<ul>
  <li>
    <p>You can configure tests <a href="https://playwright.dev/docs/test-parallel#parallelize-tests-in-a-single-file">test.describe.configure</a> to run tests in a single file in parallel.</p>
  </li>
  <li>
    <p>You can configure the entire project to have all tests in all files to run in parallel using <a href="https://playwright.dev/docs/api/class-testproject#test-project-fully-parallel">testProject.fullyParallel</a> or <a href="https://playwright.dev/docs/api/class-testconfig#test-config-fully-parallel">testConfig.fullyParallel</a>.</p>
  </li>
  <li>
    <p>To disable parallelism limit the number of <a href="https://playwright.dev/docs/test-parallel#disable-parallelism">workers to one</a>.</p>
  </li>
</ul>

<p>You can control the number of <a href="https://playwright.dev/docs/test-parallel#limit-workers">parallel worker processes</a> and <a href="https://playwright.dev/docs/test-parallel#limit-failures-and-fail-fast">limit the number of failures</a> in the whole test suite for efficiency.</p>
<blockquote>
  <p><strong>Playwright defaults to parallelization using spec files. It allows the configuration of the number of workers which facilitates complete parallelization, even within spec files.</strong></p>
</blockquote>

<h2 id="limit-workers">Limit workers<a href="https://playwright.dev/docs/test-parallel#limit-workers">‚Äã</a></h2>

<p>You can control the maximum number of parallel worker processes via <a href="https://playwright.dev/docs/test-cli">command line</a> or in the <a href="https://playwright.dev/docs/test-configuration">configuration file</a>.</p>

<p>From the command line:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>    npx playwright test --workers 4
</pre></td></tr></tbody></table></code></pre></div></div>
<p>In the configuration file:</p>

<p><em>playwright.config.ts</em></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre>    import { defineConfig } from '@playwright/test';
    export default defineConfig({
      // Limit the number of workers on CI, use default locally
      workers: process.env.CI ? 2 : undefined,
    });
</pre></td></tr></tbody></table></code></pre></div></div>
<blockquote>
  <p><strong>Another option is :</strong></p>
</blockquote>

<h2 id="parallelize-tests-in-a-single-file">Parallelize tests in a single file<a href="https://playwright.dev/docs/test-parallel#parallelize-tests-in-a-single-file">‚Äã</a></h2>

<p>By default, tests in a single file are run in order. If you have many independent tests in a single file, you might want to run them in parallel with <a href="https://playwright.dev/docs/api/class-test#test-describe-configure">test.describe.configure()</a>.</p>

<p>Note that parallel tests are executed in separate worker processes and cannot share any state or global variables. Each test executes all relevant hooks just for itself, including beforeAll and afterAll.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre>    import { test } from '@playwright/test';
    
    test.describe.configure({ mode: 'parallel' });
    
    test('runs in parallel 1', async ({ page }) =&gt; { /* ... */ });
    test('runs in parallel 2', async ({ page }) =&gt; { /* ... */ });
</pre></td></tr></tbody></table></code></pre></div></div>
<p>Or</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre>    import { defineConfig } from '@playwright/test';
    
    export default defineConfig({
      fullyParallel: true,
    });
</pre></td></tr></tbody></table></code></pre></div></div>
<p>To measure performance, we prepared a test framework with 4 spec files. You can access it here: 
[<em>https://github.com/Maryna-Mala/TypeScript/tree/main/tests](https://github.com/Maryna-Mala/TypeScript/tree/main/tests)</em></p>

<p><img src="https://cdn-images-1.medium.com/max/5924/1*UY2TO1mdyqKsHldmRdL63g.png" alt="[https://github.com/Maryna-Mala/TypeScript/tree/main/tests](https://github.com/Maryna-Mala/TypeScript/tree/main/tests)" /><em><a href="https://github.com/Maryna-Mala/TypeScript/tree/main/tests">https://github.com/Maryna-Mala/TypeScript/tree/main/tests</a></em></p>

<h3 id="what-we-compare">What we compare:</h3>
<blockquote>
  <h1 id="--4-test-spec-files-without-parallelization-sequentially">- 4 test spec files, without parallelization (sequentially).</h1>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="rouge-code"><pre>npx playwright test &gt; # ‚ÄúDefault parallelization‚Äù &gt; # - 4 test spec files, default parallelization (2 workers).

npx playwright test - workers 2 &gt; # - 4 test spec files, default parallelization (4 workers).

npx playwright test - workers 4 &gt; # ‚ÄúFull parallelization‚Äù &gt; # - 4 test spec files, full parallelization (2 workers) ```
import { defineConfig } from '@playwright/test';

export default defineConfig({
  fullyParallel: true,
}); ```
npx playwright test - workers 2 &gt; # - 4 test spec files, full parallelization (4 worker) ```
import { defineConfig } from '@playwright/test';

export default defineConfig({
  fullyParallel: true,
}); ```
npx playwright test - workers 4
</pre></td></tr></tbody></table></code></pre></div></div>

<p><strong><em>We conducted each test scenario three times to ensure a robust analysis.</em></strong></p>

<p><img src="https://cdn-images-1.medium.com/max/2000/1*dF0nWBD7a8abqR7-1ZaPqw.png" alt="" /></p>

<p>Results showed that using 4 workers for 4 spec files was the most efficient method as marked in bold. This configuration, which uses 1 worker per file, yielded the fastest results. Surprisingly, ‚Äúfull parallelization,‚Äù did not enhance speed and was slightly slower than the default parallelization with the same number of workers.</p>

<h3 id="conclusion">Conclusion</h3>

<p>Playwright‚Äôs parallelization support effectively decreases test execution times compared to sequential processing, notably when running numerous tests. The configuration is straightforward and tends to perform optimally when simply splitting into test files.</p>

<p><strong><em>Thanks to everyone who read this article, I hope you found it useful.</em></strong></p>

<p>I would also like to thank <a href="https://www.linkedin.com/in/maryna-mala-5592a5177">Maryana</a> for her help in conducting and collecting data for this article.</p>]]></content><author><name>Vadym Nastoiashchyi</name></author><category term="JavaScript" /><category term="Playwright" /><category term="Performance" /><summary type="html"><![CDATA[Time is of the essence in software testing, where achieving quicker test results without compromising reliability is a primary objective for development teams. Playwright, an open-source browser automation library, is instrumental in testing modern web applications across different browsers. Parallelization further enhances the efficacy and efficiency of automated testing by reducing execution times...]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/images/posts/2024-12-05-playwright-compare-the-performance-of-different-test-parallelization-approaches/0_OWmrZjf95TDjGa2B.webp" /><media:content medium="image" url="http://localhost:4000/assets/images/posts/2024-12-05-playwright-compare-the-performance-of-different-test-parallelization-approaches/0_OWmrZjf95TDjGa2B.webp" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">JavaScript üÜö TypeScript in Test Automation. A Closer Look at Playwright and Cypress</title><link href="http://localhost:4000/javascript-typescript-in-test-automation-a-closer-look-at-playwright-and-cypress" rel="alternate" type="text/html" title="JavaScript üÜö TypeScript in Test Automation. A Closer Look at Playwright and Cypress" /><published>2024-04-01T22:00:00+03:00</published><updated>2024-04-01T22:00:00+03:00</updated><id>http://localhost:4000/javascript-typescript-in-test-automation-a-closer-look-at-playwright-and-cypress</id><content type="html" xml:base="http://localhost:4000/javascript-typescript-in-test-automation-a-closer-look-at-playwright-and-cypress"><![CDATA[<p><img src="http://localhost:4000/assets/images/posts/2024-04-01-javascript-typescript-in-test-automation-a-closer-look-at-playwright-and-cypress/0_awmiCTtuNj9yrQQ4.webp" alt="_config.yml" class="align-center border max-width-600px" /></p>

<p>For any software development project, selecting the right language and tools is crucial to ensure effective test automation. Two languages that have caught the attention of developers worldwide are JavaScript (JS) and TypeScript (TS). Let‚Äôs dive into a comparison between these two languages, and specifically how they apply in two popular testing tools ‚Äî Playwright and Cypress.</p>

<h3 id="javascript-vs-typescript"><strong><em>JavaScript VS TypeScript:</em></strong></h3>

<p>JavaScript, a high-level interpreted language, has proven its worth due to its compatibility across browsers. This dynamic language has an easy learning curve and is the backbone of many frameworks and libraries used in web development.</p>
<blockquote>
  <p><strong><em>Pros:</em></strong></p>
  <ul>
    <li><em>Ease of Use:</em> JavaScript has a less steep learning curve and is easier to set up. It‚Äôs ideal for beginners who want to start coding quickly.</li>
    <li><em>Flexibility:</em> JavaScript is dynamically typed, allowing more flexibility in writing code.</li>
    <li><em>Popularity:</em> Being around for a long time, JavaScript has a large community, abundant resources, and widespread support across browsers and platforms.
<strong>Cons:</strong></li>
    <li>*Lack of Type Safety: *The biggest drawback of JavaScript is its lack of static type-checking, increasing the possibility of runtime errors.</li>
    <li><em>Less Suitable for large-scale applications:</em> For complex applications, the lack of static types can lead to difficulties in maintaining and scaling the codebase.</li>
  </ul>
</blockquote>

<p>On the other hand, TypeScript, a statically typed superset of JavaScript, offers additional features like type checking that catches potential bugs at compile time. TypeScript enhances code quality and understandability, hence making maintenance easier.</p>

<p>However, TypeScript‚Äôs learning curve is steeper compared to JavaScript. It may also require additional setup time, as TypeScript code has to be transpiled to JavaScript to run in a browser.</p>
<blockquote>
  <p><strong>Pros:</strong></p>
  <ul>
    <li><em>Static Type-Checking:</em> TypeScript‚Äôs main advantage is its ability to check types at compile time, allowing for early error detection.</li>
    <li>*Scalability: *TypeScript is more structured and robust, making it best suited for large-scale project development.</li>
    <li><em>Down Compilation:</em> TypeScript code can be compiled down to a JavaScript version for broader browser compatibility.
<strong>Cons:</strong></li>
    <li><em>Learning Curve:</em> TypeScript has a steeper learning curve than JavaScript due to its typing system and more complex syntax.</li>
    <li><em>Compilation Step:</em> TypeScript needs an extra compilation step to transpile down to JavaScript, which can slow down development.</li>
    <li><em>Verbose Syntax:</em> Due to static typing and advanced features, TypeScript can have more verbose syntax compared to JavaScript.</li>
  </ul>
</blockquote>

<p>In a nutshell, the choice between JavaScript and TypeScript comes down to your team‚Äôs skills and the requirements of your project. Your decision may also depend on your development environment: If your team values type safety and uses large codebases, TypeScript could be the better choice. If your team consists of novice programmers coding a small project, JavaScript may be the way to go.</p>

<h3 id="playwright-and-cypress-javascript-vs-typescript"><strong><em>Playwright and Cypress JavaScript vs TypeScript:</em></strong></h3>

<p><a href="https://playwright.dev/">Playwright</a> and <a href="https://www.cypress.io/">Cypress</a> are two advanced, modern automation testing tools that can be used with both JavaScript and TypeScript. Playwright supports multiple browsers and offers fast, reliable, and capable automation for web components by using the modern browser API. Alternatively, Cypress focuses on providing a comprehensive end-to-end testing experience.</p>

<p>Choosing between JavaScript and TypeScript when working with Playwright and Cypress depends on various factors, including your team‚Äôs skillset, the complexity of the project, and personal preference.</p>

<p><strong><em>JavaScript:</em></strong></p>

<p><strong>Playwright</strong> ‚Äî Choosing JavaScript could make sense if your team is more comfortable with dynamic typing or if you want to avoid the setup that TypeScript requires. Also, if your project isn‚Äôt very complex and doesn‚Äôt require the added type of safety that TypeScript provides, then using JavaScript could be a better choice<em>.</em></p>

<p><img src="http://localhost:4000/assets/images/posts/2024-04-01-javascript-typescript-in-test-automation-a-closer-look-at-playwright-and-cypress/1_5ogof1Qa-HzaFLE5L1bZPA.webp" alt="_config.yml" class="align-center border max-width-600px" /></p>

<blockquote>
  <p>Playwright supports JavaScript out of the box. There is nothing to configure. Only Node.js to be installed</p>
</blockquote>

<p><strong>Cypress</strong> ‚Äî was initially built to support JavaScript. If your team is more comfortable with JavaScript or if you‚Äôre working on a small to mid-sized project, using Cypress with JavaScript can be a good option.</p>

<p><img src="http://localhost:4000/assets/images/posts/2024-04-01-javascript-typescript-in-test-automation-a-closer-look-at-playwright-and-cypress/1_D6It49zCZXwBbm1VbH6V6A.webp" alt="_config.yml" class="align-center border max-width-600px" /></p>

<blockquote>
  <p>Cypress supports JavaScript out of the box. There is nothing to configure. Only Node.js to be installed</p>
</blockquote>

<p><img src="http://localhost:4000/assets/images/posts/2024-04-01-javascript-typescript-in-test-automation-a-closer-look-at-playwright-and-cypress/0_s9gFJiK-JOtumHuQ.webp" alt="_config.yml" class="align-center border max-width-600px" /><em>Cypress with JS</em></p>

<p><strong><em>TypeScript</em></strong>:</p>

<p><strong>Playwright</strong> ‚Äî TypeScript could be a better choice for larger, more complex projects where type safety can help prevent bugs. By catching errors early at compile time, you can save time and resources that would have been spent finding and fixing them at runtime. TypeScript also provides better autocompletion, making it easier to use Playwright APIs.</p>
<blockquote>
  <p>To support TypeScript, you must specify Playwright during the initial installation:</p>
</blockquote>

<p><img src="http://localhost:4000/assets/images/posts/2024-04-01-javascript-typescript-in-test-automation-a-closer-look-at-playwright-and-cypress/0_s9gFJiK-JOtumHuQ.webp" alt="_config.yml" class="align-center border max-width-600px" /><em>Just choose your preferred programming language ‚Äî and the Playwright does it all.</em></p>

<blockquote>
  <p>Or install everything listed manually:</p>
</blockquote>

<ul>
  <li><strong>add <a href="http://www.typescriptlang.org/docs/handbook/tsconfig-json.html">tsconfig.json</a></strong></li>
</ul>

<p><img src="http://localhost:4000/assets/images/posts/2024-04-01-javascript-typescript-in-test-automation-a-closer-look-at-playwright-and-cypress/1_VuFoqxkXr1AcuJY9TAuqgA.webp" alt="_config.yml" class="align-center border max-width-600px" /><em>To use all TypeScript ‚Äúmagic‚Äù use command <strong>‚Äúnpx tsc -p tsconfig.json ‚Äî noEmit -w‚Äù</strong></em></p>

<p>[<strong><em>Playwright TypeScript configuration example](https://github.com/VadimNastoyashchy/playwright-saucedemo.com)</em></strong></p>

<p><strong>Cypress</strong> ‚Äî However, if type safety is crucial for your project, or if you‚Äôre working on a larger codebase, TypeScript could be the better choice. TypeScript‚Äôs static typing can help catch errors during compile-time before they crash your application. This feature, combined with improved autocompletion and tooling support, often leads to cleaner, more maintainable codebases.</p>
<blockquote>
  <p>To support TypeScript, you must install the nessesary dependancy and add ts configuration:</p>
</blockquote>

<ul>
  <li>
    <p><strong><em>npm install ‚Äî save-dev typescript</em></strong></p>
  </li>
  <li>
    <p><strong>add <a href="http://www.typescriptlang.org/docs/handbook/tsconfig-json.html">tsconfig.json</a></strong></p>
  </li>
</ul>

<p><a href="https://github.com/VadimNastoyashchy/demoblaze.com">Cypress TypeScript configuration example</a></p>

<p>In conclusion, choosing between JavaScript and TypeScript, and between Playwright and Cypress, depends on your project needs, team skills, and specific requirements. TypeScript, combined with Playwright or Cypress, is an excellent choice for large-scale projects where reliability, maintainability, and advanced features are crucial. On the other hand, JavaScript, because of its simplicity, remains a solid choice for quick and effective test automation.</p>

<p><strong><em>Thanks to everyone who read this article to the end, I hope you found it useful.</em></strong></p>

<p>Sources used in the article:
<a href="https://github.com/VadimNastoyashchy/playwright-saucedemo.com">https://github.com/VadimNastoyashchy/playwright-saucedemo.com</a>
<a href="https://github.com/VadimNastoyashchy/demoblaze.com">https://github.com/VadimNastoyashchy/demoblaze.com</a>
<a href="https://docs.cypress.io/guides/tooling/typescript-support">https://docs.cypress.io/guides/tooling/typescript-support</a>
<a href="https://playwright.dev/docs/test-typescript">https://playwright.dev/docs/test-typescript</a></p>]]></content><author><name>Vadym Nastoiashchyi</name></author><category term="JavaScript" /><category term="TypeScript" /><category term="Cypress" /><category term="Playwright" /><summary type="html"><![CDATA[For any software development project, selecting the right language and tools is crucial to ensure effective test automation. Two languages that have caught the attention of developers worldwide are JavaScript (JS) and TypeScript (TS). Let‚Äôs dive into a comparison between these two languages, and specifically how they apply in two popular testing tools ‚Äî Playwright and Cypress...]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/images/posts/2024-04-01-javascript-typescript-in-test-automation-a-closer-look-at-playwright-and-cypress/0_awmiCTtuNj9yrQQ4.webp" /><media:content medium="image" url="http://localhost:4000/assets/images/posts/2024-04-01-javascript-typescript-in-test-automation-a-closer-look-at-playwright-and-cypress/0_awmiCTtuNj9yrQQ4.webp" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">üé≠Playwright. How to build Page Object correctly using fixtures</title><link href="http://localhost:4000/Playwright-how-to-pom" rel="alternate" type="text/html" title="üé≠Playwright. How to build Page Object correctly using fixtures" /><published>2024-01-22T21:00:00+02:00</published><updated>2024-01-22T21:00:00+02:00</updated><id>http://localhost:4000/Playwright-how-to-pom</id><content type="html" xml:base="http://localhost:4000/Playwright-how-to-pom"><![CDATA[<p><img src="http://localhost:4000/assets/images/posts/2024-1-22-Playwright-how-to-pom/1_1aQ9ki7tVGg9edYFJJnM-g.webp" alt="_config.yml" class="align-center border max-width-600px" /></p>

<p>This article is useful for test automation engineers or developers who are involved in testing and who want to improve their testing framework skills to use Page Object models for test organization, maintenance, and relations between themself. It can also be useful for those engineers who already use this method but would like to hear a different point of view.</p>

<p>Let‚Äôs consider a simple test scenario:</p>

<p><img src="http://localhost:4000/assets/images/posts/2024-1-22-Playwright-how-to-pom/1__wp3jH63vsKpsIhI5CAjbg.webp" alt="_config.yml" class="align-center border max-width-600px" /></p>

<p>First of all, we need to open the home page (as we can see it‚Äôs an entry point ‚Äòhttps://www.saucedemo.com/‚Äô). When the page is opened we validate it. Then we want to proceed with getting appropriate selectors for input fields filling user name and password there, and clicking on the ‚Äúlog in‚Äù button.
But, what will happen if want to add new tests with another type of user for example admin user? We will need to duplicate our code at least once.
And let‚Äôs hope that the locator on our frontend application does not change, say from data-test=‚Äùlogin-button‚Äù to data-test=‚Äùsign-in-button‚Äù, otherwise we will need to go through all the test scenarios where this locator is used and fix it. It is very time-consuming to correct such errors.</p>

<p>The solution is the Page Object model.
Short explanations:</p>

<p><img src="http://localhost:4000/assets/images/posts/2024-1-22-Playwright-how-to-pom/1_HIHpbj3Qyp5i68AfBZMTIA.webp" alt="_config.yml" class="align-center border max-width-600px" /></p>

<p>There are a lot of articles, videos, and tutorials on the Internet regarding the Page object model. Now I want to share my vision of how to build pages correctly.</p>

<p>(if you want additional examples, please navigate to &gt; <a href="https://github.com/VadimNastoyashchy/playwright-saucedemo.com">https://github.com/VadimNastoyashchy/playwright-saucedemo.com</a>)</p>

<figure id="image" class="image">
  <img src="http://localhost:4000/assets/images/posts/2024-1-22-Playwright-how-to-pom/1_OKGGP_VSOoayYVPOKZaxjA.webp" alt="test.js" />
  <figcaption id="img-caption">test.js</figcaption>
</figure>

<figure id="image" class="image">
  <img src="http://localhost:4000/assets/images/posts/2024-1-22-Playwright-how-to-pom/1_VfkjxXJme7o6Kltu3hVETQ.webp" alt="Login page" />
  <figcaption id="img-caption">Login page</figcaption>
</figure>

<figure id="image" class="image">
  <img src="http://localhost:4000/assets/images/posts/2024-1-22-Playwright-how-to-pom/1_E7zy9fJ_Qh9Yns5LPFyY5A.webp" alt="Abstraction for Page‚Äôs" />
  <figcaption id="img-caption">Abstraction for Page‚Äôs</figcaption>
</figure>

<p>For components, I prefer the same level of detail:</p>

<figure id="image" class="image">
  <img src="http://localhost:4000/assets/images/posts/2024-1-22-Playwright-how-to-pom/1_cb25bT4812A-xR8VQq81xQ.webp" alt="Header component" />
  <figcaption id="img-caption">Header component</figcaption>
</figure>

<figure id="image" class="image">
  <img src="http://localhost:4000/assets/images/posts/2024-1-22-Playwright-how-to-pom/1_8cEpaRu9ce_Q7dukj-85kA.webp" alt="Abstraction for Components" />
  <figcaption id="img-caption">Abstraction for Components</figcaption>
</figure>

<p>Now it looks better. But still, we need to initialize our pages with { page } fixture in each test block:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre>  test('Login with \'standard\' user with set cookies', async ({ page }) =&gt; {
        const loginPage = new LoginPage(page);
        const inventoryPage = new InventoryPage(page);
    });
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Below I will give examples of the organization of classes and methods. Let us take a closer look at the Fixtures!</p>

<p><img src="http://localhost:4000/assets/images/posts/2024-1-22-Playwright-how-to-pom/1_bUZJ4kYznUv7eIolqvdmiA.webp" alt="_config.yml" class="align-center border max-width-600px" /></p>

<p>First, we need to create a file. Let‚Äôs name it FixtureConfig.ts
Then we need to define the type of our pages and override the test fixture config:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="rouge-code"><pre>import { test as base } from '@playwright/test';
import LoginPage from './pages/LoginPage';
import InventoryPage from './pages/InventoryPage';
import ApiService from './ApiService';

type MyFixtures = {
  loginPage: LoginPage;
  inventoryPage: InventoryPage;
  apiService: ApiService;
};

export const test = base.extend&lt;MyFixtures&gt;({
  loginPage: async ({ page }, use) =&gt; {
    const loginPage = new LoginPage(page);
    await use(loginPage);
  },
  inventoryPage: async ({ page }, use) =&gt; {
    const inventoryPage = new InventoryPage(page);
    await use(inventoryPage);
  },
  apiService: async ({ page }, use) =&gt; {
    const apiService = new ApiService(page);
    await use(apiService);
  },

});
export { expect } from '@playwright/test';
</pre></td></tr></tbody></table></code></pre></div></div>

<p>In the end, you need to change the import inside your test file
from:</p>

<p><img src="http://localhost:4000/assets/images/posts/2024-1-22-Playwright-how-to-pom/1_Qb1coTY2ZxxPl67ply9X8Q.webp" alt="_config.yml" class="align-center border max-width-600px" /></p>

<p>into:</p>

<p><img src="http://localhost:4000/assets/images/posts/2024-1-22-Playwright-how-to-pom/1_ujPZiHen6wHlyh5R64Z8XQ.webp" alt="_config.yml" class="align-center border max-width-600px" /></p>

<p>Now you can use a Fixture inside your test via a fixture object that includes all your pages that were defined in a FixtureConfig.ts file:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre>test.describe('Login and Logout test', () =&gt; {
    test('Login with \'standard\' user', async ({ page, loginPage, inventoryPage }) =&gt; {
        await loginPage.open();
        await expect(await page.url()).toContain(await loginPage.getPageUrl());
        await loginPage.logInWithCredentials(Credentials.getUserCredentials(AccountType.Standard));
        await expect(await page.url()).toContain(await inventoryPage.getPageUrl());
    });
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Sources used in the article:</p>

<p><a href="https://playwright.dev/docs/test-fixtures">https://playwright.dev/docs/test-fixtures</a></p>

<p><a href="https://github.com/VadimNastoyashchy/playwright-saucedemo.com">https://github.com/VadimNastoyashchy/playwright-saucedemo.com</a></p>]]></content><author><name>Vadym Nastoiashchyi</name></author><category term="JavaScript" /><category term="Playwright" /><summary type="html"><![CDATA[This article is useful for test automation engineers or developers who are involved in testing and who want to improve their testing framework skills to use Page Object models for test organization, maintenance, and relations between themself. It can also be useful for those engineers who already use this method but would like to hear a different point of view...]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/images/posts/2024-1-22-Playwright-how-to-pom/1_1aQ9ki7tVGg9edYFJJnM-g.webp" /><media:content medium="image" url="http://localhost:4000/assets/images/posts/2024-1-22-Playwright-how-to-pom/1_1aQ9ki7tVGg9edYFJJnM-g.webp" xmlns:media="http://search.yahoo.com/mrss/" /></entry></feed>