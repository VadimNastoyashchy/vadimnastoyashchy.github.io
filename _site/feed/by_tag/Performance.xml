<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-US"><generator uri="https://jekyllrb.com/" version="3.9.5">Jekyll</generator><link href="http://localhost:4000/feed/by_tag/Performance.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="en-US" /><updated>2026-01-14T13:53:07+02:00</updated><id>http://localhost:4000/feed/by_tag/Performance.xml</id><title type="html">Vadym Nastoiashchyi</title><subtitle>Software quality fanatic | Software Engineer in Test</subtitle><author><name>Vadym Nastoiashchyi</name></author><entry><title type="html">üé≠Playwright Parallelism: Why the Playwright sharding approach speeds up test execution over workers?</title><link href="http://localhost:4000/playwright-parallelism-why-the-playwright-sharding-approach-speeds-up-test-execution" rel="alternate" type="text/html" title="üé≠Playwright Parallelism: Why the Playwright sharding approach speeds up test execution over workers?" /><published>2026-01-10T21:00:00+02:00</published><updated>2026-01-10T21:00:00+02:00</updated><id>http://localhost:4000/playwright-parallelism-why-the-playwright-sharding-approach-speeds-up-test-execution</id><content type="html" xml:base="http://localhost:4000/playwright-parallelism-why-the-playwright-sharding-approach-speeds-up-test-execution"><![CDATA[<p><img src="http://localhost:4000/assets/images/posts/2026-01-10-playwright-parallelism-why-the-playwright-sharding-approach-speeds-up-test-execution/0_ibq0p6HzRRqGlPYv.png" alt="_config.yml" class="align-center border max-width-600px" /></p>

<p>In the previous article, I introduced you to <a href="https://medium.com/javascript-in-plain-english/playwright-compare-the-performance-of-different-test-parallelization-approaches-7698f1ee6523">üé≠ Playwright. Compare the performance of different test parallelization approaches.</a> Now, I shift the focus to test parallelization with the sharding approach, which plays a vital role in accelerating test execution using Playwright as a test framework.</p>

<p>The topic of parallel test execution has always interested other test automation engineers and me, regardless of the automated testing tools we use. In this article, I explain how Playwright works with parallelism and offer recommendations based on my research and analysis.</p>

<h2 id="to-properly-understand-parallelism-in-playwright-we-need-to-take-a-quick-look-at-low-level-computer-architecture">To properly understand parallelism in Playwright, we need to take a quick look at low-level computer architecture.</h2>

<p><em>I promise it won‚Äôt take long, but it might be a bit boring.</em></p>

<p>Our computer (my and yours) consists of various components, such as a hard drive, RAM, and a processor, etc. Here, we are most interested in the processor, specifically its ‚ÄúClock Speed‚Äù and the number of cores. Cores play an important role in the simultaneous execution of parallel processes. ‚ÄúClock Speed‚Äù determines how much work the processor can do in a given time. Here‚Äôs more information: <a href="https://www.intel.com/content/www/us/en/gaming/resources/cpu-clock-speed.html">What Is Clock Speed?</a></p>

<p>The following scheme provides us with greater visualization capabilities that we will apply to our Playwright parallelization mechanism:</p>

<p><img src="http://localhost:4000/assets/images/posts/2026-01-10-playwright-parallelism-why-the-playwright-sharding-approach-speeds-up-test-execution/1_nfZZJif8Lb1Hh49gxUGjBw.jpeg" alt="_config.yml" class="align-center border max-width-600px" /></p>

<p>When we use Playwright on one computer with the <code class="language-plaintext highlighter-rouge">--workers=</code> flag to run our tests in parallel, a Node.js process will be created for us. More information about processes can be found <a href="https://dev-aditya.medium.com/understanding-processes-and-threads-in-node-js-a-deep-dive-into-concurrency-and-parallelism-67e2cd2d5f0c">here</a>.</p>

<p>There is a clear dependency between workers and processor cores here. If there are fewer workers than cores, everything will work properly. As shown in the diagram, everything will execute in parallel at the same time.</p>

<p><img src="http://localhost:4000/assets/images/posts/2026-01-10-playwright-parallelism-why-the-playwright-sharding-approach-speeds-up-test-execution/1_TYCcNcPTTYPjUN9OeID1SQ.png" alt="_config.yml" class="align-center border max-width-600px" /></p>

<p>However, if we have 4 workers and 2 processor cores, certain workers will not run truly in parallel. Not everything will run at the same time, but processor time will be shared.</p>

<p><img src="http://localhost:4000/assets/images/posts/2026-01-10-playwright-parallelism-why-the-playwright-sharding-approach-speeds-up-test-execution/1_rCVNsTeTxe0qZZIcQ0il9Q.png" alt="_config.yml" class="align-center border max-width-600px" /></p>

<p>For example, on a CI/CD runner where we run our tests with more workers than available cores, we will not see an improvement in test execution time. This is because the workers share the processor time on the available cores. Even though we specify 10 or 20 workers.</p>

<p>You ask, ‚ÄúWhat should I do in this case?‚Äù It‚Äôs simple: Add additional runners using the sharding mechanism. For each runner, you can specify the number of workers based on the number of cores available on the processors. More information about sharding <a href="https://playwright.dev/docs/test-sharding">here</a></p>

<p><a href="https://github.com/VadimNastoyashchy/vadimnastoyashchy.github.io/blob/master/.github/workflows/pr_master.yml">Here is an example of how to describe the sharding mechanism in GitHub Actions:</a></p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="rouge-code"><pre><span class="na">e2e_tests</span><span class="pi">:</span>
  <span class="na">timeout-minutes</span><span class="pi">:</span> <span class="m">60</span>
  <span class="na">runs-on</span><span class="pi">:</span> <span class="s">ubuntu-latest</span>
  <span class="na">env</span><span class="pi">:</span>
    <span class="na">CI</span><span class="pi">:</span> <span class="no">true</span>
  <span class="na">strategy</span><span class="pi">:</span>
    <span class="na">fail-fast</span><span class="pi">:</span> <span class="no">false</span>
    <span class="na">matrix</span><span class="pi">:</span>
      <span class="na">shardIndex</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">1</span><span class="pi">,</span> <span class="nv">2</span><span class="pi">,</span> <span class="nv">3</span><span class="pi">,</span> <span class="nv">4</span><span class="pi">]</span>
      <span class="na">shardTotal</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">4</span><span class="pi">]</span>
  <span class="na">steps</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Checkout repository</span>
      <span class="na">uses</span><span class="pi">:</span> <span class="s">actions/checkout@v2</span>

    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Setup Node.js</span>
      <span class="na">uses</span><span class="pi">:</span> <span class="s">actions/setup-node@v2</span>
      <span class="na">with</span><span class="pi">:</span>
        <span class="na">node-version</span><span class="pi">:</span> <span class="s1">'</span><span class="s">22'</span>

    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Install E2E dependencies</span>
      <span class="na">run</span><span class="pi">:</span> <span class="s">npm ci</span>

    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Install Playwright browsers</span>
      <span class="na">run</span><span class="pi">:</span> <span class="s">npx playwright install --with-deps</span>

    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Run regression tests</span>
      <span class="na">run</span><span class="pi">:</span> <span class="s">npx playwright test --shard=$/$ --workers=2</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>In such an example, 4 runners (computers) and 2 workers for each. So we have 8 truly parallel processes.</p>

<h2 id="summary">Summary</h2>

<p>In summary, we can continuously improve the execution time of our tests by adding more runners (computers), provided that we follow best practices when developing and designing tests with an independent architecture.</p>

<p>I hope this article has shed some light on the obscure area of parallelization. Improve your test execution times, and remember about processor cores)</p>]]></content><author><name>Vadym Nastoiashchyi</name></author><category term="JavaScript" /><category term="Playwright" /><category term="Performance" /><category term="CI/CD" /><summary type="html"><![CDATA[In this article, I explain how Playwright works with parallelism and offer recommendations based on my research and analysis. The topic of parallel test execution has always interested other test automation engineers and me, regardless of the automated testing tools we use.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/images/posts/2026-01-10-playwright-parallelism-why-the-playwright-sharding-approach-speeds-up-test-execution/0_ibq0p6HzRRqGlPYv.png" /><media:content medium="image" url="http://localhost:4000/assets/images/posts/2026-01-10-playwright-parallelism-why-the-playwright-sharding-approach-speeds-up-test-execution/0_ibq0p6HzRRqGlPYv.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">üîùJavaScript UI Test Automation Frameworks ‚Äî which one is faster?</title><link href="http://localhost:4000/javascript-ui-test-automation-frameworks-which-one-is-faster" rel="alternate" type="text/html" title="üîùJavaScript UI Test Automation Frameworks ‚Äî which one is faster?" /><published>2024-12-17T21:00:00+02:00</published><updated>2024-12-17T21:00:00+02:00</updated><id>http://localhost:4000/javascript-ui-test-automation-frameworks-which-one-is-faster</id><content type="html" xml:base="http://localhost:4000/javascript-ui-test-automation-frameworks-which-one-is-faster"><![CDATA[<p><img src="http://localhost:4000/assets/images/posts/2024-12-17-javascript-ui-test-automation-frameworks-which-one-is-faster/1_jlskksKL_ZgiQzxnoeoYPw.webp" alt="_config.yml" class="align-center border max-width-600px" /></p>

<p><em>I continue to share interesting experiences and tips from the automation testing world. So far we‚Äôve discussed the following:</em></p>

<p><img src="https://medium.com/javascript-in-plain-english/playwright-compare-the-performance-of-different-test-parallelization-approaches-7698f1ee6523" alt="[*üé≠Playwright. Compare the performance of different test parallelization approaches.](https://medium.com/javascript-in-plain-english/playwright-compare-the-performance-of-different-test-parallelization-approaches-7698f1ee6523)*](https://cdn-images-1.medium.com/max/2540/1*VdHXUgs7bNmA8kA8VO8Evg.png)[*üé≠Playwright. Compare the performance of different test parallelization approaches." /></p>

<p><em>Today I have prepared an equally interesting article. As you can see from the title, we are going to compare the performance of three of the most popular system (UI) testing tools. 
<a href="https://playwright.dev/">Playwright</a>, <a href="https://webdriver.io/">WebdriverIO</a>, and <a href="https://www.cypress.io/">Cypress</a> will be our guinea pigs today.</em></p>

<p>When choosing the right automation tool for testing, we are usually guided by the programming language our team works in, the need to support certain browsers, whether we need to support mobile testing, how we can parallelize tests, how the tool will be supported and extended, and so on. And that is true. In addition to the above, knowing the test execution performance (speed) of a particular tool will be a plus when deciding what to use for automated testing.</p>

<h3 id="why-playwright">Why Playwright?</h3>
<blockquote>
  <p>‚Äî Multi-browser Support: Playwright supports all the major browsers (Chromium, Firefox, and WebKit) out of the box, which means you can test across all browsers with the same API.
 ‚Äî Cross-platform: It works on Windows, Linux, and macOS.
 ‚Äî Auto-waits: The API automatically waits for elements to be ready before performing actions, reducing flakiness in tests.
 ‚Äî Rich set of APIs: Offers APIs to simulate various inputs including keyboard, mouse, and touch, as well as network and context manipulation.
 ‚Äî Language Support: First-class support for JavaScript/TypeScript, and community-driven support for Python, Java, and C#.</p>
</blockquote>

<h3 id="why-webdriverio">Why WebDriverIO?</h3>
<blockquote>
  <p>‚Äî Flexible: It runs on top of Selenium, which means it has wide support for almost all browsers, even mobile browsers via Appium.
 ‚Äî Feature-rich: Contains a lot of plugins and services that can be integrated, like visual regression testing tools, and reporter tools, and even extends its functionalities using custom commands.
 ‚Äî Support for Multiple Test Frameworks: It supports Mocha, Jasmine, and Cucumber, meaning that you can use it with a variety of testing styles.
 ‚Äî Good community and ecosystem: Due to its integration with Selenium, it has a very strong community and a lot of third-party tools.</p>
</blockquote>

<h3 id="why-cypress">Why Cypress?</h3>
<blockquote>
  <p>‚Äî Developer-friendly: Provides a unique interactive test runner that allows you to see commands as they execute while also viewing the application UI.
 ‚Äî Automatic Waiting: Automatically waits for commands and assertions before moving on. No need to define explicit waits.
 ‚Äî Real-Time Reloads: Automatically reloads whenever you make changes to tests.
 ‚Äî Built-in Debuggability: You can use familiar dev tools for debugging directly during test execution.
 ‚Äî Network Traffic Control: Easily control, stub, and test edge cases without involving your server. You can intercept and modify network traffic on the fly.</p>
</blockquote>

<p>Together with <a href="https://www.linkedin.com/in/maryna-mala-5592a5177/">Maryna</a>, we prepared three repositories for these three tools, with four tests that were the same according to the scenario. For each of these tools, we checked the sequential execution of the tests in one thread locally and on GitHub action (one single machine). We ran the tests 3 times for data accuracy and took the total execution time from the average value.
Links to the repositories: <a href="https://github.com/Maryna-Mala/test-performance-playwright">Playwright</a> / <a href="https://github.com/Maryna-Mala/test-performance-wdio">WebdriverIO</a> / <a href="https://github.com/Maryna-Mala/test-performance-cypress">Cypress</a></p>

<h3 id="1-locally-run">#1 Locally run</h3>

<p><em>configuration:</em></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>MacBook Air m1 |  RAM 8 gb | SSD 256 | browser - chrome
</pre></td></tr></tbody></table></code></pre></div></div>

<p><img src="https://cdn-images-1.medium.com/max/3520/1*DmyIWnxZpfrbyiw_GOpObg.png" alt="" /></p>

<h3 id="results">Results:</h3>

<p><img src="https://cdn-images-1.medium.com/max/2000/1*IgYwEoEnn_qtuFZ4xXydlQ.png" alt="" /></p>

<p>We ran each tool three times, and as you can see from the results, Playwright took <em>13.4</em> seconds to complete, while WebdriverIO and Cypress took almost as long ‚Äî <em>18.3</em> and <em>18.7</em> seconds, respectively.</p>

<p><img src="https://cdn-images-1.medium.com/max/2000/1*JThx0MXsiBZeHcZ7Wrwmsw.png" alt="" /></p>

<h3 id="2-ci-run-githubaction">#2 CI run GithubAction</h3>

<p><em>configuration:</em></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre>Standard GitHub-hosted runners

Virtual Machine | (CPU) | (RAM) | (SSD) | Workflow
Linux           | 4     | 16 GB | 14 GB | ubuntu-latest
</pre></td></tr></tbody></table></code></pre></div></div>

<p>The situation with CI is a bit different. We measured the execution time of the tool itself as well as the execution time of the command. Some tools require additional time for verification or configuration before the runner is launched.</p>

<p><img src="https://cdn-images-1.medium.com/max/3008/1*YsuuBbYZDx76MI15vQawJQ.png" alt="" /></p>

<p><img src="https://cdn-images-1.medium.com/max/2000/1*RsWm2a-KLd3H_bXkukicEg.png" alt="" /></p>

<p>The Playwright was also the fastest tool in the CI run.</p>

<p><img src="https://cdn-images-1.medium.com/max/4180/1*y-0sWT7jGXNZPRZg6W0nMw.png" alt="playwright 15.8 sec / 17 sec" /><em>playwright 15.8 sec / 17 sec</em></p>

<p><img src="https://cdn-images-1.medium.com/max/4168/1*L3YIrbMUfZfm1eRtgfV_Tw.png" alt="webdriverio 30 sec / 32sec" /><em>webdriverio 30 sec / 32sec</em></p>

<p><img src="https://cdn-images-1.medium.com/max/4188/1*c4CgKVRJpA1Coq8FOu3kaw.png" alt="cypress 22 sec / 41sec" /><em>cypress 22 sec / 41sec</em></p>

<h3 id="conclusion">Conclusion</h3>

<p>The comparison of the three JavaScript UI test automation frameworks ‚Äî Playwright, WebdriverIO, and Cypress ‚Äî revealed notable differences in their performance both locally and on CI using GitHub Actions. Playwright emerged as the fastest tool in both environments, significantly outperforming the other two frameworks. Its comprehensive browser support, cross-platform capabilities, and robust APIs make it an advantageous choice for developers seeking efficiency and reliability in UI testing. WebdriverIO and Cypress also demonstrated commendable features, each suited to different testing needs and environments. This comparison provides valuable insight for teams considering automated testing tools, allowing them to make informed decisions based on speed, functionality, and compatibility with their testing needs.</p>

<p><strong><em>Thanks to everyone who read this article, I hope you found it useful.</em></strong></p>

<p>I would also like to thank <a href="https://www.linkedin.com/in/maryna-mala-5592a5177">Maryna</a> for her help in conducting and collecting data for this article.</p>]]></content><author><name>Vadym Nastoiashchyi</name></author><category term="JavaScript" /><category term="Playwright" /><category term="Cypress" /><category term="WebdriverIO" /><category term="Performance" /><summary type="html"><![CDATA[Today I have prepared an equally interesting article. As you can see from the title, we are going to compare the performance of three of the most popular system (UI) testing tools. Playwright, WebdriverIO, and Cypress will be our guinea pigs today...]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/images/posts/2024-12-17-javascript-ui-test-automation-frameworks-which-one-is-faster/1_jlskksKL_ZgiQzxnoeoYPw.webp" /><media:content medium="image" url="http://localhost:4000/assets/images/posts/2024-12-17-javascript-ui-test-automation-frameworks-which-one-is-faster/1_jlskksKL_ZgiQzxnoeoYPw.webp" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">üé≠Playwright. Compare the performance of different test parallelization approaches.</title><link href="http://localhost:4000/playwright-compare-the-performance-of-different-test-parallelization-approaches" rel="alternate" type="text/html" title="üé≠Playwright. Compare the performance of different test parallelization approaches." /><published>2024-12-05T21:00:00+02:00</published><updated>2024-12-05T21:00:00+02:00</updated><id>http://localhost:4000/playwright-compare-the-performance-of-different-test-parallelization-approaches</id><content type="html" xml:base="http://localhost:4000/playwright-compare-the-performance-of-different-test-parallelization-approaches"><![CDATA[<p><img src="http://localhost:4000/assets/images/posts/2024-12-05-playwright-compare-the-performance-of-different-test-parallelization-approaches/0_OWmrZjf95TDjGa2B.webp" alt="_config.yml" class="align-center border max-width-600px" /></p>

<p><em>I continue to share tips for playwrights and in the previous article, I showed you <a href="https://medium.com/softwaretestingdaily/playwright-how-to-build-page-object-correctly-using-fixtures-ff0a8c05b395">how to build a Page Object correctly using fixtures</a>. Now, I shift the focus to test parallelization, which plays a vital role in accelerating test execution using Playwright as a test framework.</em></p>

<p>Time is of the essence in software testing, where achieving quicker test results without compromising reliability is a primary objective for development teams. Playwright, an open-source browser automation library, is instrumental in testing modern web applications across different browsers. Parallelization further enhances the efficacy and efficiency of automated testing by reducing execution times.</p>

<p>In this article, we won‚Äôt delve into setting up parallelization but rather explore the variations in test execution times when deploying different parallelizing approaches.</p>

<p>According to the <a href="https://playwright.dev/docs/test-parallel">official documentation</a>:</p>

<h2 id="parallelism">Parallelism<a href="https://playwright.dev/docs/test-parallel#introduction">‚Äã</a></h2>

<p>Playwright Test runs tests in parallel. To achieve that, several worker processes are run at the same time. By default, test files are run in parallel. Tests in a single file are run in order, in the same worker process.</p>

<ul>
  <li>
    <p>You can configure tests <a href="https://playwright.dev/docs/test-parallel#parallelize-tests-in-a-single-file">test.describe.configure</a> to run tests in a single file in parallel.</p>
  </li>
  <li>
    <p>You can configure the entire project to have all tests in all files to run in parallel using <a href="https://playwright.dev/docs/api/class-testproject#test-project-fully-parallel">testProject.fullyParallel</a> or <a href="https://playwright.dev/docs/api/class-testconfig#test-config-fully-parallel">testConfig.fullyParallel</a>.</p>
  </li>
  <li>
    <p>To disable parallelism limit the number of <a href="https://playwright.dev/docs/test-parallel#disable-parallelism">workers to one</a>.</p>
  </li>
</ul>

<p>You can control the number of <a href="https://playwright.dev/docs/test-parallel#limit-workers">parallel worker processes</a> and <a href="https://playwright.dev/docs/test-parallel#limit-failures-and-fail-fast">limit the number of failures</a> in the whole test suite for efficiency.</p>
<blockquote>
  <p><strong>Playwright defaults to parallelization using spec files. It allows the configuration of the number of workers which facilitates complete parallelization, even within spec files.</strong></p>
</blockquote>

<h2 id="limit-workers">Limit workers<a href="https://playwright.dev/docs/test-parallel#limit-workers">‚Äã</a></h2>

<p>You can control the maximum number of parallel worker processes via <a href="https://playwright.dev/docs/test-cli">command line</a> or in the <a href="https://playwright.dev/docs/test-configuration">configuration file</a>.</p>

<p>From the command line:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>    npx playwright test --workers 4
</pre></td></tr></tbody></table></code></pre></div></div>
<p>In the configuration file:</p>

<p><em>playwright.config.ts</em></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre>    import { defineConfig } from '@playwright/test';
    export default defineConfig({
      // Limit the number of workers on CI, use default locally
      workers: process.env.CI ? 2 : undefined,
    });
</pre></td></tr></tbody></table></code></pre></div></div>
<blockquote>
  <p><strong>Another option is :</strong></p>
</blockquote>

<h2 id="parallelize-tests-in-a-single-file">Parallelize tests in a single file<a href="https://playwright.dev/docs/test-parallel#parallelize-tests-in-a-single-file">‚Äã</a></h2>

<p>By default, tests in a single file are run in order. If you have many independent tests in a single file, you might want to run them in parallel with <a href="https://playwright.dev/docs/api/class-test#test-describe-configure">test.describe.configure()</a>.</p>

<p>Note that parallel tests are executed in separate worker processes and cannot share any state or global variables. Each test executes all relevant hooks just for itself, including beforeAll and afterAll.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre>    import { test } from '@playwright/test';
    
    test.describe.configure({ mode: 'parallel' });
    
    test('runs in parallel 1', async ({ page }) =&gt; { /* ... */ });
    test('runs in parallel 2', async ({ page }) =&gt; { /* ... */ });
</pre></td></tr></tbody></table></code></pre></div></div>
<p>Or</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre>    import { defineConfig } from '@playwright/test';
    
    export default defineConfig({
      fullyParallel: true,
    });
</pre></td></tr></tbody></table></code></pre></div></div>
<p>To measure performance, we prepared a test framework with 4 spec files. You can access it here: 
[<em>https://github.com/Maryna-Mala/TypeScript/tree/main/tests](https://github.com/Maryna-Mala/TypeScript/tree/main/tests)</em></p>

<p><img src="https://cdn-images-1.medium.com/max/5924/1*UY2TO1mdyqKsHldmRdL63g.png" alt="[https://github.com/Maryna-Mala/TypeScript/tree/main/tests](https://github.com/Maryna-Mala/TypeScript/tree/main/tests)" /><em><a href="https://github.com/Maryna-Mala/TypeScript/tree/main/tests">https://github.com/Maryna-Mala/TypeScript/tree/main/tests</a></em></p>

<h3 id="what-we-compare">What we compare:</h3>
<blockquote>
  <h1 id="--4-test-spec-files-without-parallelization-sequentially">- 4 test spec files, without parallelization (sequentially).</h1>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="rouge-code"><pre>npx playwright test &gt; # ‚ÄúDefault parallelization‚Äù &gt; # - 4 test spec files, default parallelization (2 workers).

npx playwright test - workers 2 &gt; # - 4 test spec files, default parallelization (4 workers).

npx playwright test - workers 4 &gt; # ‚ÄúFull parallelization‚Äù &gt; # - 4 test spec files, full parallelization (2 workers) ```
import { defineConfig } from '@playwright/test';

export default defineConfig({
  fullyParallel: true,
}); ```
npx playwright test - workers 2 &gt; # - 4 test spec files, full parallelization (4 worker) ```
import { defineConfig } from '@playwright/test';

export default defineConfig({
  fullyParallel: true,
}); ```
npx playwright test - workers 4
</pre></td></tr></tbody></table></code></pre></div></div>

<p><strong><em>We conducted each test scenario three times to ensure a robust analysis.</em></strong></p>

<p><img src="https://cdn-images-1.medium.com/max/2000/1*dF0nWBD7a8abqR7-1ZaPqw.png" alt="" /></p>

<p>Results showed that using 4 workers for 4 spec files was the most efficient method as marked in bold. This configuration, which uses 1 worker per file, yielded the fastest results. Surprisingly, ‚Äúfull parallelization,‚Äù did not enhance speed and was slightly slower than the default parallelization with the same number of workers.</p>

<h3 id="conclusion">Conclusion</h3>

<p>Playwright‚Äôs parallelization support effectively decreases test execution times compared to sequential processing, notably when running numerous tests. The configuration is straightforward and tends to perform optimally when simply splitting into test files.</p>

<p><strong><em>Thanks to everyone who read this article, I hope you found it useful.</em></strong></p>

<p>I would also like to thank <a href="https://www.linkedin.com/in/maryna-mala-5592a5177">Maryana</a> for her help in conducting and collecting data for this article.</p>]]></content><author><name>Vadym Nastoiashchyi</name></author><category term="JavaScript" /><category term="Playwright" /><category term="Performance" /><summary type="html"><![CDATA[Time is of the essence in software testing, where achieving quicker test results without compromising reliability is a primary objective for development teams. Playwright, an open-source browser automation library, is instrumental in testing modern web applications across different browsers. Parallelization further enhances the efficacy and efficiency of automated testing by reducing execution times...]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/images/posts/2024-12-05-playwright-compare-the-performance-of-different-test-parallelization-approaches/0_OWmrZjf95TDjGa2B.webp" /><media:content medium="image" url="http://localhost:4000/assets/images/posts/2024-12-05-playwright-compare-the-performance-of-different-test-parallelization-approaches/0_OWmrZjf95TDjGa2B.webp" xmlns:media="http://search.yahoo.com/mrss/" /></entry></feed>